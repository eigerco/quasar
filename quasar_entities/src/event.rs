//! `SeaORM` Entity. Generated by sea-orm-codegen 0.12.3
use async_graphql::ComplexObject;
use sea_orm::{entity::prelude::*, ActiveValue, Set};
use serde_json::json;
use stellar_xdr::{ContractEvent, Error, ScVal, WriteXdr};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, async_graphql::SimpleObject)]
#[sea_orm(table_name = "events")]
#[graphql(complex)]
#[graphql(name = "Events")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub topic: String,
    pub contract_id: String,
    pub transaction_id: String,
    pub value: Json,
    pub r#type: String,
}

#[ComplexObject]
impl Model {}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}

impl TryFrom<ContractEvent> for ActiveModel {
    type Error = Error;

    fn try_from(event: ContractEvent) -> Result<Self, Self::Error> {
        println!("{event:?}");
        let (topic, value) = match &event.body {
            stellar_xdr::ContractEventBody::V0(body) => {
                let topic = &body.topics[0];
                let topic = match topic {
                    ScVal::Symbol(topic) => topic.to_string().unwrap(),
                    _ => {
                        panic!("not a symbol")
                    }
                };
                let value = val_to_json(&body.data);
                (topic, value)
            }
        };
        Ok(Self {
            id: ActiveValue::NotSet,
            topic: ActiveValue::Set(topic),
            contract_id: Set(stellar_strkey::Contract(event.contract_id.unwrap().0).to_string()),
            transaction_id: ActiveValue::NotSet,
            value: ActiveValue::Set(value),
            r#type: Set(event.type_.to_string()),
        })
    }
}

fn val_to_json(val: &ScVal) -> Json {
    match val {
        ScVal::Bool(val) => json!(val),
        ScVal::Error(e) => json!({
            "error": e.to_xdr_base64().unwrap()
        }),
        ScVal::U32(val) => json!(val),
        ScVal::I32(val) => json!(val),
        ScVal::U64(val) => json!(val),
        ScVal::I64(val) => json!(val),
        ScVal::Timepoint(t) => json!(t.0),
        ScVal::Duration(d) => json!(d.0),
        ScVal::U128(val) => json!({
            "hi": val.hi,
            "low": val.lo
        }),
        ScVal::I128(val) => json!({
            "hi": val.hi,
            "low": val.lo
        }),
        ScVal::U256(val) => json!({
            "hi_hi": val.hi_hi,
            "hi_lo": val.hi_lo,
            "lo_hi": val.lo_hi,
            "lo_lo": val.lo_lo,
        }),
        ScVal::I256(val) => json!({
            "hi_hi": val.hi_hi,
            "hi_lo": val.hi_lo,
            "lo_hi": val.lo_hi,
            "lo_lo": val.lo_lo,
        }),
        ScVal::Bytes(val) => json!({
            "bytes_xdr": val.to_xdr_base64().unwrap()
        }),
        ScVal::String(val) => json!(val.to_string().unwrap()),
        ScVal::Symbol(s) => json!({
            "symbol": s.to_string().unwrap()
        }),
        ScVal::Vec(val) => match val {
            Some(val) => val.iter().map(|v| val_to_json(v)).collect::<Json>(),
            None => Json::Null,
        },
        ScVal::Map(map) => match map {
            Some(val) => val
                .iter()
                .map(|v| {
                    let key = val_to_json(&v.key).to_string();
                    let val = val_to_json(&v.val);
                    json!({
                        key: val
                    })
                })
                .collect::<Json>(),
            None => Json::Null,
        },
        ScVal::Address(a) => json!({
            "address": println!("{a:?}")
        }),
        _ => Json::Null,
    }
}
